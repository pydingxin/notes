git连不上github
一般是dns污染，有个项目GitHub520，专门解决这个问题。
----------------------------------------------------------------
git status
查看提交和暂存状态
----------------------------------------------------------------
.gitconfig

git默认分支是master，
比如git bash显示：
baba@baba-PC MINGW64 ~/Desktop/pywenwu-/pingyi-wenwu (main)

而github默认是main，这样传到github上就出现2个分支。

方法1：修改git配置，把默认master改为main：
在用户文件夹下有个.gitconfig文件，添加配置即可：
[init]
	defaultBranch=main

此时git bash显示：
baba@baba-PC MINGW64 ~/Desktop/pywenwu-/pingyi-wenwu (main)

方法2：在github创建repo时修改默认分支名字为master。
方法3：在github建立repo后，在分支管理里修改main分支名字为master。

----------------------------------------------------------------
git init
为当前文件夹新建一个仓库，即在当前目录下新建一个.git文件夹，这个文件夹就是本地库。

----------------------------------------------------------------
git的操作对象是文件，新建/删除/修改文件后，把修改的文件用add命令添加到暂存区，git才能检测到变化。

----------------------------------------------------------------
git add a.txt	把a.txt添加到暂存区
git add *txt 	txt结尾的文件
git add . 		当前目录所有文件
-A 保存所有的修改 【除了.gitignore指定不跟踪的文件】
在此过程中，对添加的文件进行哈希，根据哈希值判断是否有修改，若有则添加到暂存区。

----------------------------------------------------------------
哈希值就是“身份证号”
工作区就是实际使用的目录，暂存区就是内存，库就是.git目录

----------------------------------------------------------------
.gitignore 文件
每个库都可以自建一个该文件，与.git文件夹同级
这个东西有专门的语法，每行都是一条匹配规则。比如忽视整个node_modules文件夹：
/node_modules

----------------------------------------------------------------
git commit -m "msg"
把暂存区的改变写入到.git文件夹，比如
在 .git/objects/ 把文件、目录结构、提交详情这三种信息分别保存为二进制文件。
在 .git/logs/ 里写入记录之类等

提交后，暂存区就清空了。
"msg"是区分提交记录的主要信息，必须写清楚。
所有提交都按时间排序，上次提交是下次的父节点。

----------------------------------------------------------------
git log
按时间顺序列出所有提交记录。每个提交都是变动的一个“快照”，都有哈希值。

git log //打印提交记录
git log <commit id> //打印从第一次到该次的提交记录
git log -n //打印最近n次提交记录

--oneline 每个提交只显示一行信息
--graph 图形化显示

----------------------------------------------------------------
工作区所有文件在某个时刻的内容就是一个版本，这个版本是可以前进后退的。

git reset --hard hashcode
设某次提交x的哈希值为hashcode，该命令把工作区的文件，重置为x，即该次提交后的状态。

x之后的提交记录，比如y，用git log就看不见了，如果要回到y怎么办？
可以用git reflog查看，找到y的哈希。然后同样可以用这个命令，把工作区重置为y。

git reset 有三个模式 --soft --mix --hard，另外两个用处不大。
----------------------------------------------------------------
git branch img
创建一个叫img的分支，分支文件保存在.git/refs/heads/里。
每新建一个分支就在本地库生成一个文件，文件内容就是该分支的哈希值。
每个分支都有自己的提交记录列表。

----------------------------------------------------------------
创建分之后，要切换过去，否则还是在主分支上提交，不能生成正确的镜像。
git switch img //切换到img分支，命令行会显示当前所在的分支。

----------------------------------------------------------------
git merge img -m "msg"
合并分支，形成一个特殊的提交记录。
merge是主线命令，用于合并支线。
找到两条线的源头，把主线和支线的提交，从头到尾合并一遍。
如果支线没做rebase，把两条线的提交按时间顺序依次合并，这会造成很多交叉，非常难看[用git log查看]
如果支线做了rebase，主线在前支线在后，就很清晰。

----------------------------------------------------------------
git rebase main
把当前分支上的所有提交记录，顺序放到主线新的提交记录后边，形成一条直线。
rebase是支线命令，把主线的变化及时合并过来。

也有一种用法，支线rebase主线，支线完成后，主线再rebase支线，效果一样。
----------------------------------------------------------------
主线和支线各自前进的时候，如果支线没完成，则：
1、不应该改变主线的方向。
2、主线上每个后续提交都是该支线的父节点，因为人家是主线。
所以支线要及时用rebase把主线的变动整合过来。

等到这个支线完成后，主线只做一次merge。
理想情况下，rebase配合merge，形成如下结构
M1—————————M2——M3————————————M4
   \B1——B2/       \C1—C2-..C7/

这样分支不与主线的提交纠缠，还能清晰看到每个人的工作，每个功能的完善过程。

----------------------------------------------------------------

单机环境中，add/commit/reset这三个命令就能做很好的版本管理。
自己开分支，配合rebase、merge，基本能满足开发需求。
----------------------------------------------------------------
git clone 
克隆一个远程库，好像只能克隆自己账号的库。

----------------------------------------------------------------
git pull [origin main] 
拉取远程库，merge到当前分支

git pull [origin main] [--rebase]
拉取远程库，merge到当前分支

----------------------------------------------------------------
git push 
把本地库推到远程库对应分支
