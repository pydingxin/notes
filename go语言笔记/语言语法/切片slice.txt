切片就是动态数组，类似c++/python

静态数组和动态数组不是一回事。
go的数组，就是一模一样的C语言的静态数组，变量直接指向数据本身。
go的动态数组是一个结构体，变量指向24字节的结构体，结构体指向数据。

大概长这样：
struct Slice
{   
    byte*    array;       // 指向分配的内存块
    uintgo    len;        // number of elements
    uintgo    cap;        // allocated number of elements

};
//-----------------------------------------------------------------

区别很简单：
	x:=[2]int8{} //指明长度的是静态数组
	x:=[]int8{}	 //自动推断长度的是动态数组

	x:=[2][2]int8{} //两个维度都指明了大小，x/x[0]/x[1]都是数组，x占4字节，x[1]占2字节
	x:=[2][]int8{}	//x[0]/x[1]是动态数组结构体，各占24字节。x是数组，存着两个结构体，占48字节
	x:=[][2]int8{}	//x是动态数组的结构体，占24字节。x[0]/x[1]是数组，各占2字节
	x:=[][]int8{}	//x是动态数组结构体，占24字节。它的元素必须也是动态数组，不能是数组。

	对x:=[][]int8{}，append(x,[1]int8{1}) 是错误的，必须 append(x,[]int8{1})，往里塞结构体。

//-----------------------------------------------------------------
go的形参默认是按值传递，会复制实参指向的东西，传递给形参。

func do(x [3]int8) 传递数组，会复制数据本身，也就是3字节的数据块，不能改变实参指向的数据。
func do(x []int8)  传递动态数组，会复制动态数组的那个结构体，它里面是带着指针的，可以改变实参指向的数据。

//-----------------------------------------------------------------

用内置函数显式定义动态数组：
make([]type, len, capacity)
申请了一块内存，可以放 capacity 个 type 数据，已经用了len个

动态数组的截取和python完全一样
arr[L:R] arr[:R] arr[L:]

内置函数len(arr) cap(arr)可以查看动态数组的内存使用情况

//-----------------------------------------------------------------
append函数
	arr:= []int{1}
	arr = append(arr, 2,3,4) //返回[1,2,3,4]

append是值传递函数，第一个参数是一个切片结构体的拷贝，返值也是一个切片结构体。

//-----------------------------------------------------------------

append是把元素塞进arr指向的内存里：
1、如果有空间，就直接塞进去，返回当前结构体；
2、如果空间不够，新建一个动态数组，重新分内存，返回新结构体
所以，给arr增加元素，必须 arr = append(arr, ele1,ele2...)给arr重新复制。

//-----------------------------------------------------------------

切片的机制，很容易产生不确定性
情景0：
	brr:=arr
arr/brr直接指向同一个内存

情景1、append以后随意赋给另外一个变量，比如
	brr:= append(arr, ele1,ele2...)
arr/brr两个结构体，可能指向同一块内存，也可能指向不同的内存。

情景2、切片作函数参数 func do(brr []int){...}
形参brr 和 实参arr 指向的是同一块内存，会修改原值。
在函数do内部，append了brr，则又指向不同内存，又无法修改原值了。

这种切片指向的不确定性问题，不妨叫切片纠缠。

//-----------------------------------------------------------------

切片展开
append函数要求第一个参数是切片，后面的参数数元素，所以只能尾部追加。
要追加到头部，就要用省略号语法，把切片展开成元素:
	arr:= []int{0,0}
	brr:= []int{1,1}
	arr = append(brr, arr...)
动态数组可以，静态数组不能这么展开。
当然这只是个例子，真这么干，很可能切片纠缠。


//-----------------------------------------------------------------

要正确理解切片，必须区分‘切片’和‘切片指向的数据’，
切片就是指针!
切片就是指针!!
切片就是指针!!!
切片指向的东西，才是数据。
所以,空切片变量打印出来是[]，但其值为nil。

c语言里，指针比这复杂得多，切片有类似问题很正常。

