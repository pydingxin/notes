go的管道类似js的流，是自动读写的数据交换区
但js阻塞的是函数，go阻塞的是goroutine

chan      //双向管道
chan<-    //只进管道
<-chan    //只出管道

chan int    //int类型双向管道
chan<- int  //int类型只进管道
<-chan int  //int类型只出管道

ch:= make(chan int)//实例化int类型双向管道
make(chan<- int)   //实例化int类型只进管道
make(<-chan int)   //实例化int类型只出管道

make时不指大小或指定为0，默认为无缓冲管道

make(chan int, 100) //缓冲区为100个元素
make(chan<- int, 100)
make(<-chan int, 100)

close(ch) //关闭管道
关闭后，不可写，仍可读


ch<- a      //写数据
a:= <-ch    //读取，并返回数据
a,b:= <-ch  //读取多个数据

满时写/空时读，则阻塞当前协程。管道阻塞某协程后 满足要求时，激活此协程。
这都是自动的

ch<-3 这是一条完整的语句，不可拆分
a:= <-ch 这也是一条完整的语句，但 <-ch 是一个表达式，可单独使用

ch:= make(int chan,100)
defer close(ch) //初始化必须配合defer

用range遍历管道，可持续处理。
与其他数据类型不同，range管道返回的只有一个值，不是键值对
    for val:= range ch{
        p(val)
    }
-----------------------------------------------

一个管道就能阻塞协程，要并行等待多管道，得用select。
select类似于switch，但用于通信操作。

    for{
        select{
            case x= <-ch1:
                ...
            case y= <-ch2:
                ...
        }
    }
    
-----------------------------------------------
select的执行逻辑是：
第一、从上到下，从左往右，把这三类表达式求值：
    ch <- exp
    .. <- ch
    得到一个chan集合，和待发送的数据[注意1]。
    表达式中的副作用都会发生。


第二、如果有可用的chan，用伪随机法选一个。
    如无可用，执行default。
    如无default，阻塞本协程，等待任一个可用
第三、执行选中的通信。
第四、如果是<-ch表达式，执行其左侧表达式（如果有）
第五、执行选中case下的表达式。

注意2：如果不能简单判断哪边是管道，所有表达式都会被求值
包括exp <- ch的exp，可能导致其上下文的丢失。
总之最好认为，所有case的左右表达式都被求值了。
-----------------------------------------------

关于管道传送字符串，会复制字符串的控制块，到管道的缓存里，但字符本身会被销毁，这显然达不到目的。可以使用strings模块的Reader发送字节，用Builder重建字符串。

-----------------------------------------------

对无缓冲chan，没有任何存放数据的地方，一个位置都没有。读会阻塞，写也阻塞，其读写必然是：一个协程唤醒被阻塞的另一个协程。所以必须2个协程都就绪，单个协程做不到。








