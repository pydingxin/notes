struct是数据集，interface是函数集，都是用type定义
	type duck_action interface{
		fly()
		walk(int)string
		jump()
	}

如果有接口变量，则可调用其定义的函数，
	var x duck_action
	x.fly()
	x.jump()

//----------------------------------------------------------------
鸭子类型：“当一只鸟走起来像鸭子、游泳像鸭子、叫起来像鸭子，那这只鸟就可以被称为鸭子”。
在面向对象编程中，继承是为了多态式调用。而鸭子类型正是一种多态风格，即不显式继承，直接使用多态。
	鸭子A = 行为像鸭子的鸟A
	鸭子B = 行为像鸭子的鸟B
	鸭子C = 行为像鸭子的鸟C

如果结构体绑定了接口定义的函数类型，则结构体变量也可那样调用函数，与接口变量行为一样。

//----------------------------------------------------------------

如果 structA/structB 绑了 interfaceX 描述的那些函数类型，可按其要求调用这些函数，则 
	var x:= []interfaceX{ new(structA), new(structB)}
不用指明谁继承了谁，多态直接就出现了。
类似c++/java/python/typescript那套继承语法全丢掉，关系的描述放到文档里。一切都极其精简。

注意new函数，new(structA)，输入一个结构体类型，产生一个结构体实例。