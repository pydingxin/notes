--------------------------------------------------------------
正式/非正式 定义

全局变量必须正式定义 var x int=3
不能冒号定义 x:=3

函数内定义函数，必须冒号定义 f1:= func(){}
不能正式定义 func f1(){}

err可以重复定义
--------------------------------------------------------------

凡读数据，都用io库定义的接口，如
    br:= bytes.NewReader([]byte("ding"))
    sr:= strings.NewReader("ding")
    fr:= os.Open(path)

file打开就是，string/bytes有专门的Reader
其他类型同理
都定义了Read/ReadAt..之类的东西
--------------------------------------------------------------
用go env看环境变量：

GOROOT【C:\Program Files\Go\src】存放标准库包。

GOPATH【C:\Users\Administrator\go】
下有一个pkg文件夹，存放平时项目下载的依赖库包，比如github.com下载了就放这里。
这个会有检测，GOPATH有的包，应该不会重复下载。
--------------------------------------------------------------
包引入1

自己写的包，假设放在文件夹dir1中，dir1要放在GOROOT里
dir1里可以有好几个文件，每个文件叫什么无所谓，头部注明package dir1，他们就都属于dir1这个包。
当 import "dir1" 时，dir1里所有go文件都会被引入，执行各自init()，dir1的子文件夹不会引入。
所有dir1下go文件里的大写的东西，都会放到 dir1这个作用域里，类似dir1.Hello()来使用

dir1下可以有子文件夹dir2
同理，dir2下所有文件都在头部注明 package dir2
当 import "dir1/dir2"时，只引入dir2下的所有文件，不引入dir1下的
同理用 dir2.A()来使用

--------------------------------------------------------------
包引入2

圆括号多行引入，等于import放到每行前面
import f "fmt" 命名，即f=fmt
import _ "fmt" 匿名，不使用其任何东西，只执行其init函数。
import . "fmt" 导入到当前作用域，直接使用Printf

每个go文件，都可以有多个init函数，用于一些初始化操作，import时执行其init
只有主文件叫main.go，用package main，定义main()
--------------------------------------------------------------
包引入3

设main.go在dir_name，要引入当前目录下的东西test.go，用go init dir_name，把当前文件夹注册为主包
test.go放到子文件夹test里，抬头写package test
这样在main.go中就能 import "dir_name/test" 了
引入包是很工程化的。
--------------------------------------------------------------
包引入4
例：go get gorm.io/gorm
把包下载到GOPATH里，并添加到本项目的go.sum/go.mod里，然后可以在代码里import。
如果GOPATH有缓存，就用缓存。
缓存的版本可能较旧，用go get -u 强制从网络上更新。
若只下载到GOPATH里，用go get -d。
--------------------------------------------------------------
--------------------------------------------------------------
--------------------------------------------------------------
--------------------------------------------------------------